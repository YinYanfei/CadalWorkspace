package cn.cadal.rec.algo.tags;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class TagSimilar {

	private String TAGINFO="E:/Recommendation/Tags/anaTags_op_forward.dat";
	private String SIMILAR_1="E:/Recommendation/Tags/tag_similar_1.res";
	private String SIMILAR_2="E:/Recommendation/Tags/tag_similar_2.res";
	
	public Map<Integer, int []> hashTagInfo = null;
	public List<int []> listTagInfo = null;
	
	/**
	 * Constuct functions
	 */
	public TagSimilar(){
	}
	public TagSimilar(String taginfo, String similar_1, String similar_2){
		this.TAGINFO = taginfo;
		this.SIMILAR_1 = similar_1;
		this.SIMILAR_2 = similar_2;
	}
	
	/**
	 * Read file and into this.hashTagInfo or this.listTagInfo
	 * 		-- For first storing into this.hashTagInfo
	 * 		-- For second storing inro this.listTagInfo
	 */
	public void ReadIntoHashTagInfo(){
		
	}
	public void ReadIntoListTagInfo(){
		
	}
	
	/**
	 * Calculate frame
	 * 		-- For first to calculate each similar between each tag
	 * 		-- For second to calculate each similar for tagno with others
	 * 		-- For third to calculate similar between tagno_1 and tagno_2
	 */
	public void CalFrame(){
		
	}
	public void CalFrame(int tagno){
		
	}
	public double CalFrame(int tagno_1, int tagno_2) {
	
		return 0.0;
	}
	
	/**
	 * The methods to calculate the similar
	 * 
	 */
	private double CosineSimilar(int [] tagInfoOne, int [] tagInfoTwo){
		if(tagInfoOne == null || tagInfoOne.length < 0 || tagInfoTwo == null || tagInfoTwo.length < 0){
			return 0.0;
		}
		
		Map<Integer, int[]> algorithmMap = new HashMap<Integer, int[]>();
		for(int i = 0; i < tagInfoOne.length; ++i) {
			int [] fq = algorithmMap.get(tagInfoOne[i]);
			if(fq != null && fq.length == 2){
				fq[0]++;
			}else {
				fq = new int[2];
				fq[0] = 1;
				fq[1] = 0;
				algorithmMap.put(tagInfoOne[i], fq);
			}
		}
		for(int i = 0; i < tagInfoTwo.length; ++i) {
			int [] fq = algorithmMap.get(tagInfoTwo[i]);
			if(fq != null && fq.length == 2) {
				fq[1]++;
			}else{
				fq = new int[2];
				fq[0] = 0;
				fq[1] = 1;
				algorithmMap.put(tagInfoTwo[i], fq);
			}
		}
		
		Iterator<Integer> iterator = algorithmMap.keySet().iterator();
		double sq1 = 0;
		double sq2 = 0;
		double denominator = 0; 
		while(iterator.hasNext()){
			int[] c = algorithmMap.get(iterator.next());
			denominator += c[0]*c[1];
			sq1 += c[0]*c[0];
			sq2 += c[1]*c[1];
		}

		double res = denominator / Math.sqrt(sq1*sq2);
		
		if(Double.isNaN(res))
			return 0.0;
		
		return res;
	}
	private double JaccardSimilar(int [] tagInfoOne, int [] tagInfoTwo){
		if(tagInfoOne == null || tagInfoOne.length < 0 || tagInfoTwo == null || tagInfoTwo.length < 0){
			return 0.0;
		}
		
		Map<Integer, Integer> algorithmMap = new HashMap<Integer, Integer>();
		for(int i = 0; i < tagInfoOne.length; ++i) {
			algorithmMap.put(tagInfoOne[i], 0);
		}
		for(int i = 0; i < tagInfoTwo.length; ++i) {
			if(algorithmMap.containsKey(tagInfoTwo[i])) {
				algorithmMap.put(tagInfoTwo[i], 1);
			}else{
				algorithmMap.put(tagInfoTwo[i], 0);
			}
		}
		
		Iterator<Integer> iterator = algorithmMap.keySet().iterator();
		double inter = 0;
		while(iterator.hasNext()){
			if(algorithmMap.get(iterator.next()) == 1) {
				inter++;
			}
		}
		double res = inter / algorithmMap.size();

		if(Double.isNaN(res)){
			return 0.0;
		}
		
		return res;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// Similar calculate
		TagSimilar ts = new TagSimilar();
		
		int [] tagInfoOne = {1,2,3};
		int [] tagInfoTwo = {2,3,4,5,6};
		
		System.out.println(ts.CosineSimilar(tagInfoOne, tagInfoTwo));
		System.out.println(ts.JaccardSimilar(tagInfoOne, tagInfoTwo));
		
	}

}
